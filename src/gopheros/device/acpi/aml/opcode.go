package aml

// opcode describes an AML opcode. While AML supports 256 opcodes, some of them
// are specified using a combination of an extension prefix and a code. To map
// each opcode into a single unique value the parser uses an uint16
// representation of the opcode values.
type opcode uint16

// String implements fmt.Stringer for opcode.
func (op opcode) String() string {
	for _, entry := range opcodeTable {
		if entry.op == op {
			return entry.name
		}
	}

	return "unknown"
}

// opIsLocalArg returns true if this opcode represents any of the supported local
// function args 0 to 7.
func opIsLocalArg(op opcode) bool {
	return op >= opLocal0 && op <= opLocal7
}

// opIsLocalArg returns true if this opcode represents any of the supported input
// function args 0 to 6.
func opIsArg(op opcode) bool {
	return op >= opArg0 && op <= opArg6
}

// opIsArithmetic returns true if this opcode represents an arithmetic or
// bitwise operation.
func opIsArithmetic(op opcode) bool {
	switch op {
	case opShiftLeft, opShiftRight,
		opAnd, opOr, opNand, opNor, opXor, opNot,
		opIncrement, opDecrement,
		opAdd, opSubtract, opMultiply, opMod, opDivide,
		opFindSetLeftBit, opFindSetRightBit:
		return true
	default:
		return false
	}
}

// opIsLogic returns true if this opcode represents a logic operation.
func opIsLogic(op opcode) bool {
	switch op {
	case opLEqual, opLLess, opLGreater, opLand, opLor, opLnot:
		return true
	default:
		return false
	}
}

// objType represents the object types that are supported by the AML parser.
type objType uint8

// The list of AML object types.
const (
	objTypeAny objType = iota
	objTypeInteger
	objTypeString
	objTypeBuffer
	objTypePackage
	objTypeFieldUnit
	objTypeDevice
	objTypeEvent
	objTypeMethod
	objTypeMutex
	objTypeRegion
	objTypePower
	objTypeProcessor
	objTypeThermal
	objTypeBufferField
	objTypeDDBHandle
	objTypeDebugObject
	objTypeLocalRegionField
	objTypeLocalBankField
	objTypeLocalIndexField
	objTypeLocalReference
	objTypeLocalAlias
	objTypeLocalMethodAlias
	objTypeLocalNotify
	objTypeLocalAddressHandler
	objTypeLocalResource
	objTypeLocalResourceField
	objTypeLocalScope
	objTypeLocalVariable
	objTypeMethodArgument
)

// opFlag specifies a list of OR-able flags that describe the object
// type/attributes generated by a particular opcode.
type opFlag uint16

const (
	opFlagNone opFlag = 1 << iota
	opFlagHasPkgLen
	opFlagNamed
	opFlagConstant
	opFlagReference
	opFlagArithmetic
	opFlagCreate
	opFlagReturn
	opFlagExecutable
	opFlagNoOp
	opFlagScoped
)

// is returns true if f is set in this opFlag.
func (fl opFlag) is(f opFlag) bool {
	return (fl & f) != 0
}

// opArgFlags encodes up to 7 opArgFlag values in a uint64 value.
type opArgFlags uint64

// argCount returns the number of encoded args in the given flag.
func (fl opArgFlags) argCount() (count uint8) {
	// Each argument is specified using 8 bits with 0x0 indicating the end of the
	// argument list
	for ; fl&0xf != 0; fl, count = fl>>8, count+1 {
	}

	return count
}

// arg returns the arg flags for argument "num" where num is the 0-based index
// of the argument to return. The allowed values for num are 0-6.
func (fl opArgFlags) arg(num uint8) opArgFlag {
	return opArgFlag((fl >> (num * 8)) & 0xf)
}

// contains returns true if the arg flags contain any argument with type x.
func (fl opArgFlags) contains(x opArgFlag) bool {
	// Each argument is specified using 8 bits with 0x0 indicating the end of the
	// argument list
	for ; fl&0xf != 0; fl >>= 8 {
		if opArgFlag(fl&0xf) == x {
			return true
		}
	}

	return false
}

// opArgFlag represents the type of an argument expected by a particular opcode.
type opArgFlag uint8

// The list of supported opArgFlag values.
const (
	_ opArgFlag = iota
	opArgTermList
	opArgTermObj
	opArgByteList
	opArgPackage
	opArgString
	opArgByteData
	opArgWord
	opArgDword
	opArgQword
	opArgNameString
	opArgSuperName
	opArgSimpleName
	opArgDataRefObj
	opArgTarget
	opArgFieldList
)

// String implements fmt.Stringer for opArgFlag.
func (fl opArgFlag) String() string {
	switch fl {
	case opArgTermList:
		return "opArgTermList"
	case opArgTermObj:
		return "opArgTermObj"
	case opArgByteList:
		return "opArgByteList"
	case opArgPackage:
		return "opArgPackage"
	case opArgString:
		return "opArgString"
	case opArgByteData:
		return "opArgByteData"
	case opArgWord:
		return "opArgWord"
	case opArgDword:
		return "opArgDword"
	case opArgQword:
		return "opArgQword"
	case opArgNameString:
		return "opArgNameString"
	case opArgSuperName:
		return "opArgSuperName"
	case opArgSimpleName:
		return "opArgSimpleName"
	case opArgDataRefObj:
		return "opArgDataRefObj"
	case opArgTarget:
		return "opArgTarget"
	case opArgFieldList:
		return "opArgFieldList"
	}
	return ""
}

func makeArg0() opArgFlags                     { return 0 }
func makeArg1(arg0 opArgFlag) opArgFlags       { return opArgFlags(arg0) }
func makeArg2(arg0, arg1 opArgFlag) opArgFlags { return opArgFlags(arg1)<<8 | opArgFlags(arg0) }
func makeArg3(arg0, arg1, arg2 opArgFlag) opArgFlags {
	return opArgFlags(arg2)<<16 | opArgFlags(arg1)<<8 | opArgFlags(arg0)
}
func makeArg4(arg0, arg1, arg2, arg3 opArgFlag) opArgFlags {
	return opArgFlags(arg3)<<24 | opArgFlags(arg2)<<16 | opArgFlags(arg1)<<8 | opArgFlags(arg0)
}
func makeArg5(arg0, arg1, arg2, arg3, arg4 opArgFlag) opArgFlags {
	return opArgFlags(arg4)<<32 | opArgFlags(arg3)<<24 | opArgFlags(arg2)<<16 | opArgFlags(arg1)<<8 | opArgFlags(arg0)
}
func makeArg6(arg0, arg1, arg2, arg3, arg4, arg5 opArgFlag) opArgFlags {
	return opArgFlags(arg5)<<40 | opArgFlags(arg4)<<32 | opArgFlags(arg3)<<24 | opArgFlags(arg2)<<16 | opArgFlags(arg1)<<8 | opArgFlags(arg0)
}
func makeArg7(arg0, arg1, arg2, arg3, arg4, arg5, arg6 opArgFlag) opArgFlags {
	return opArgFlags(arg6)<<48 | opArgFlags(arg5)<<40 | opArgFlags(arg4)<<32 | opArgFlags(arg3)<<24 | opArgFlags(arg2)<<16 | opArgFlags(arg1)<<8 | opArgFlags(arg0)
}

// opcodeInfo contains all known information about an opcode,
// its argument count and types as well as the type of object
// represented by it.
type opcodeInfo struct {
	op      opcode
	name    string
	objType objType

	flags    opFlag
	argFlags opArgFlags
}

// isType2 returns true if this is a Type2Opcode.
//
// Grammar:
// Type2Opcode := DefAcquire | DefAdd | DefAnd | DefBuffer | DefConcat |
//  DefConcatRes | DefCondRefOf | DefCopyObject | DefDecrement |
//  DefDerefOf | DefDivide | DefFindSetLeftBit | DefFindSetRightBit |
//  DefFromBCD | DefIncrement | DefIndex | DefLAnd | DefLEqual |
//  DefLGreater | DefLGreaterEqual | DefLLess | DefLLessEqual | DefMid |
//  DefLNot | DefLNotEqual | DefLoadTable | DefLOr | DefMatch | DefMod |
//  DefMultiply | DefNAnd | DefNOr | DefNot | DefObjectType | DefOr |
//  DefPackage | DefVarPackage | DefRefOf | DefShiftLeft | DefShiftRight |
//  DefSizeOf | DefStore | DefSubtract | DefTimer | DefToBCD | DefToBuffer |
//  DefToDecimalString | DefToHexString | DefToInteger | DefToString |
//  DefWait | DefXOr
func (oi *opcodeInfo) isType2() bool {
	switch oi.op {
	case opAcquire, opAdd, opAnd, opBuffer, opConcat,
		opConcatRes, opCondRefOf, opCopyObject, opDecrement,
		opDerefOf, opDivide, opFindSetLeftBit, opFindSetRightBit,
		opFromBCD, opIncrement, opIndex, opLand, opLEqual,
		opLGreater, opLLess, opMid,
		opLnot, opLoadTable, opLor, opMatch, opMod,
		opMultiply, opNand, opNor, opNot, opObjectType, opOr,
		opPackage, opVarPackage, opRefOf, opShiftLeft, opShiftRight,
		opSizeOf, opStore, opSubtract, opTimer, opToBCD, opToBuffer,
		opToDecimalString, opToHexString, opToInteger, opToString,
		opWait, opXor:
		return true
	default:
		return false
	}
}

// isArg returns true if this is a local or method argument
// opcode.
func (oi *opcodeInfo) isArg() bool {
	return opIsArg(oi.op) || opIsLocalArg(oi.op)
}

// isDataObject returns true if this opcode is part of a
// DataObject definition.
//
// Grammar:
// DataObject := ComputationalData | DefPackage | DefVarPackage
// ComputationalData := ByteConst | WordConst | DWordConst | QWordConst | String | ConstObj | RevisionOp | DefBuffer
// ConstObj := ZeroOp | OneOp | OnesOp
func (oi *opcodeInfo) isDataObject() bool {
	switch oi.op {
	case opBytePrefix, opWordPrefix, opDwordPrefix, opQwordPrefix, opStringPrefix,
		opZero, opOne, opOnes, opRevision, opBuffer, opPackage, opVarPackage:
		return true
	default:
		return false
	}
}

// isBufferField returens true if this opcode describes a
// buffer field creation operation.
func (oi *opcodeInfo) isBufferField() bool {
	switch oi.op {
	case opCreateField, opCreateBitField, opCreateByteField, opCreateWordField, opCreateDWordField, opCreateQWordField:
		return true
	default:
		return false
	}
}
